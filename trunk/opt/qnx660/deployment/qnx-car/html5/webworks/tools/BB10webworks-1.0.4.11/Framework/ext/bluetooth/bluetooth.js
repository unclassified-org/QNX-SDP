/**
 * The abstraction layer for Bluetooth functionality
 *
 * @author mlapierre, mlytvynyuk
 * $Id: bluetooth.js 4692 2012-10-22 20:02:34Z mlytvynyuk@qnx.com $
 */

var _pps = require('../../lib/pps/ppsUtils'),
	_remoteDevicesPPS,
	_pairedDevicesPPS,
	_controlPPS,
	_settingsPPS,
	_statusPPS,
	_servicesPPS,

	_pairedDevices = {},

	_newDeviceTrigger,
	_newPairedDeviceTrigger,
	_pairingCompleteTrigger,
	_searchCompleteTrigger,
	_searchCancelledTrigger,
	_searchStartFailedTrigger,
	_pairingFailedTrigger,
	_pairingCancelledTrigger,
	_initPairingFailTrigger,
	_initPairingSuccessTrigger,
	_authRequestTrigger,
	_commandFailedTrigger,
	_commandBusyTrigger,
	_serviceConnectedTrigger,
	_serviceConnectFailedTrigger,
	_serviceDisconnectedTrigger,
	_serviceDisconnectFailedTrigger,
	_serviceStateChanged,
	_deviceDeletedTrigger,
	_deviceDeleteFailedTrigger,
	_aclConnectedTrigger


/* TODO Please make sure that constants below are identical to ones in client.js*/
/** To exchange Legacy pin (usually hardcoded) */
var LEGACY_PIN = "LEGACY_PIN",
	/** To allow remote device connect */
	AUTHORIZE = "AUTHORIZE",
	/** Request to display dialog to enter authorization passkey */
	PASS_KEY = "PASS_KEY",
	/** Request to display dialog to confirm displayed  passkey*/
	ACCEPT_PASS_KEY = "ACCEPT_PASS_KEY",
	/** Request to display dialog display passkey*/
	DISPLAY_PASS_KEY = "DISPLAY_PASS_KEY",
	/** Defines Handsfree Profile ID */
	SERVICE_HFP = "0x111E",
	/** Defines Message Access Profile ID */
	SERVICE_MAP = "0x1134",
	/** Defines Serial Port Profile ID */
	SERVICE_SPP = "0x1101",
	/** Defines Phonebook Access Profile ID */
	SERVICE_PBAP = "0x1130",
	/** Defines Personal Area Network ID */
	SERVICE_PAN = "0x1115",
	/** Defines Phonebook Access Profile ID */
	SERVICE_AVRCP = "0x110B",
	/** Defines All allowed Profiles ID for current device*/
	SERVICE_ALL = "ALL";

	/** Non-discoverable or connectable. */
	DEVICE_NOT_ACCESSIBLE = 0;
	/** General discoverable and connectable. */
	DEVICE_GENERAL_ACCESSIBLE = 1;
	/** Limited discoverable and connectable. */
	DEVICE_LIMITED_ACCESSIBLE = 2;
	/** Connectable but not discoverable. */
	DEVICE_CONNECTABLE_ONLY = 3;
	/** Discoverable but not connectable. */
	DEVICE_DISCOVERABLE_ONLY = 4;

/* TODO Please make sure that constants above are identical to ones in client.js*/

/**
 * Method called when object changes in paired_devices directory (new paired device available)
 * @param event {Object} The PPS event
 */
function onPairedDevice(event) {
	if (event && event.data && event.data.cod && event.data.name && event.data.paired != undefined && event.data.rssi) {
		var device = {
			mac:event.objName,
			cod:event.data.cod.replace(/(\r\n|\n|\r)/gm, ""), // TODO temp fix of the bug with garbage in JSON generated by PPS-Bluetooth, remove it when PPS-Bluetooth will be fixed
			name:event.data.name,
			paired:event.data.paired,
			rssi:event.data.rssi.replace(/(\r\n|\n|\r)/gm, "") // TODO temp fix of the bug with garbage in JSON generated by PPS-Bluetooth, remove it when PPS-Bluetooth will be fixed
		};

		// saving paired device in the list to maintain local copy
		_pairedDevices[device.mac] = device;

		if (_newPairedDeviceTrigger) {
			_newPairedDeviceTrigger(device);
		}
	}
}

/**
 * onChange event handler for status PPS object
 * convenience function to reduce size of init(), not to invoke from outside
 * @param event {Object} onChange event object containing event data from PPS
 * */
function onStatusPPSChange(event) {
	/* checking if all required field are present when event generated*/
	if (event && event.data && event.data.event) {
		var mac = event.data.data;
		switch (event.data.event) {
			/* Fired when Search operation completed */
			case "BTMGR_EVENT_DEVICE_SEARCH_COMPLETE":
				if (_searchCompleteTrigger) {
					_searchCompleteTrigger();
				}
				break;
			/* Fired when  search cancelled*/
			case "BTMGR_EVENT_DEVICE_SEARCH_CANCELLED":
				if (_searchCancelledTrigger) {
					_searchCancelledTrigger();
				}
				break;
			/* Fired when  search start failed*/
			case "BTMGR_EVENT_SEARCH_START_FAIL":
				if (_searchStartFailedTrigger) {
					_searchStartFailedTrigger();
				}
				break;
			/* Indicates that Pairing completed successfully, also contains MAC of the paired device */
			case "BTMGR_EVENT_PAIRING_COMPLETE":
				if (_pairingCompleteTrigger) {
					_pairingCompleteTrigger(mac);
				}
				break;
			/* indicates that COMMAND_PAIRING failed */
			case "BTMGR_EVENT_PAIRING_FAILED":
				if (_pairingFailedTrigger) {
					_pairingFailedTrigger(mac)
				}
				break;
			/* indicates that COMMAND_PAIRING successful */
			case "BTMGR_EVENT_INIT_PAIRING_SUCCESS":
				if (_initPairingSuccessTrigger) {
					_initPairingSuccessTrigger(mac)
				}
				break;
			/* Fired when init of pairing Failed */
			case "BTMGR_EVENT_INIT_PAIRING_FAILED":
				if (_initPairingFailTrigger) {
					_initPairingFailTrigger(mac)
				}
				break;
			/* Fired when remote device asking to initiate connection */
			case "BTMGR_EVENT_AUTHORIZE_REQUIRED":
				var event = {
					mac:mac,
					type:AUTHORIZE
				}
				if (_authRequestTrigger) {
					_authRequestTrigger(event);
				}
				break;
			/* Fired when Passkey is required in order to establish pair */
			case "BTMGR_EVENT_PASSKEY_REQUIRED":
				var event = {
					mac:mac,
					type:PASS_KEY
				}
				if (_authRequestTrigger) {
					_authRequestTrigger(event);
				}
				break;
			/* Fired when numeric passkey confirmation required */
			case "BTMGR_EVENT_CONFIRM_NUMERIC_REQ":
				var event = {
					mac:mac,
					passkey:event.data.data2,
					type:ACCEPT_PASS_KEY
				}
				if (_authRequestTrigger) {
					_authRequestTrigger(event);
				}
				break;
			/* Fired when display of numeric passkey required */
			case "BTMGR_EVENT_DISPLAY_NUM_IND":
				var event = {
					mac:mac,
					passkey:event.data.data2,
					type:DISPLAY_PASS_KEY
				}
				if (_authRequestTrigger) {
					_authRequestTrigger(event);
				}
				break;
			/* generic command BT events, context is last command sent, used in case command doesn't have specific failed/success event */
			case "BTMGR_EVENT_COMMAND_FAILED":
				if (_commandFailedTrigger) {
					// we can have 2 events from stack with all data and without, we have to handle both cases
					// TODO in the future all FAILED events should be with data
					if(event.data.data && event.data.data2 && event.data.data3) {
						var event = {
							command:event.data.data,
							error:event.data.data2,
							mac:event.data.data3
						}
						_commandFailedTrigger(event);
					} else {
						_commandFailedTrigger();
					}
				}
				break;
			/* Command indicated that stack is busy finishing some other command */
			case "BTMGR_EVENT_COMMAND_BUSY":
				if (_commandBusyTrigger) {
					_commandBusyTrigger();
				}
				break;
			/* Event indicated that one of the services is connected */
			case "BTMGR_EVENT_SERVICE_CONNECTED":
				if (_serviceConnectedTrigger && event.data.data2) {
					var tiggerEvent = {mac:mac, serviceid:event.data.data2};
					_serviceConnectedTrigger(tiggerEvent);
				}
				break;
			/* Event indicated that all allowed services connected */
			case "BTMGR_EVENT_CONNECT_ALL_SUCCESS":
				if (_serviceConnectedTrigger && mac) {
					var tiggerEvent = {mac:mac, serviceid:SERVICE_ALL};
					_serviceConnectedTrigger(tiggerEvent);
				}
				break;
			/* Event indicated that connect to all services failed */
			case "BTMGR_EVENT_CONNECT_ALL_FAILURE":
				if (_serviceConnectFailedTrigger && mac) {
					var tiggerEvent = {mac:mac, serviceid:SERVICE_ALL};
					_serviceConnectFailedTrigger(tiggerEvent);
				}
				break;
			/* Event indicated that one of the services is disconnected */
			case "BTMGR_EVENT_SERVICE_DISCONNECTED":
				if (_serviceDisconnectedTrigger && event.data.data2) {
					var tiggerEvent = {mac:mac, serviceid:event.data.data2};
					_serviceDisconnectedTrigger(tiggerEvent);
				}
				break;
			/* Event indicated that all allowed services disconnected */
			case "BTMGR_EVENT_DISCONNECT_ALL_SUCCESS":
				if (_serviceDisconnectedTrigger) {
					var tiggerEvent = {mac:mac, serviceid:SERVICE_ALL};
					_serviceDisconnectedTrigger(tiggerEvent);
				}
				break;
			/* Event indicated that all allowed services disconnect failed*/
			case "BTMGR_EVENT_DISCONNECT_ALL_FAILED":
				if (_serviceDisconnectFailedTrigger) {
					var tiggerEvent = {mac:mac, serviceid:SERVICE_ALL};
					_serviceDisconnectFailedTrigger(tiggerEvent);
				}
				break;
			/* Event indicated that one specified paired device deleted */
			case "BTMGR_EVENT_DEVICE_DELETED":
				// deleting device from local list of devices when it was deleted by pps-bluetooth from the list of paired devices
				delete _pairedDevices[mac];
				if (_deviceDeletedTrigger) {
					_deviceDeletedTrigger(mac);
				}
				break;
			/* Event indicated that delete paired device failed */
			case "BTMGR_EVENT_DEVICE_DELETE_FAILED":
				if (_deviceDeleteFailedTrigger) {
					_deviceDeleteFailedTrigger(mac);
				}
				break;
			/* Event indicates a low level (ACL) connection has been established with a remote device */
			case "BTMGR_EVENT_ACL_CONNECTED":
				if (_aclConnectedTrigger) {
					_aclConnectedTrigger(mac);
				}
				break;
		}
	}
}


/**
 * Event handler to process services object change event.
 * I return snapshot of the whole status object when change detected
 * */
function onServicesPPSChange() {

	var devices = {};
	if(_servicesPPS && _servicesPPS.ppsObj) {
		devices[SERVICE_HFP] = _servicesPPS.ppsObj['hfp'];
		devices[SERVICE_SPP] = _servicesPPS.ppsObj['spp'];
		devices[SERVICE_PBAP] = _servicesPPS.ppsObj['pbap'];
		devices[SERVICE_MAP] = _servicesPPS.ppsObj['map'];
		devices[SERVICE_PAN] = _servicesPPS.ppsObj['pan'];
		devices[SERVICE_AVRCP] = _servicesPPS.ppsObj['avrcp'];
	}
	_serviceStateChanged(devices);
}

/**
 * Exports are the publicly accessible functions
 */
module.exports = {

	/**
	 * Initializes the extension,
	 * open and initialise required PPS object and event handlers
	 */
	init:function () {

		/* Initialise PPS object which populated when Search will detect new device in range */
		_remoteDevicesPPS = _pps.createObject();
		_remoteDevicesPPS.init();
		_remoteDevicesPPS.onChange = function (event) {
			if (event && event.data && event.data.cod && event.data.name && event.data.paired != undefined && event.data.rssi) {
				var device = {
					mac:event.objName,
					cod:event.data.cod.replace(/(\r\n|\n|\r)/gm, ""), // TODO temp fix of the bug with garbage in JSON generated by PPS-Bluetooth, remove it when PPS-Bluetooth will be fixed
					name:event.data.name,
					paired:event.data.paired,
					rssi:event.data.rssi.replace(/(\r\n|\n|\r)/gm, "") // TODO temp fix of the bug with garbage in JSON generated by PPS-Bluetooth, remove it when PPS-Bluetooth will be fixed
				};

				if (_newDeviceTrigger) {
					_newDeviceTrigger(device);
				}
			}
		};
		_remoteDevicesPPS.open("/pps/services/bluetooth/remote_devices/.all", JNEXT.PPS_RDONLY);

		/* Initialise PPS object which populated when user Paired with device */
		_pairedDevicesPPS = _pps.createObject();
		_pairedDevicesPPS.init();

		/* We have to monitor onReady and onChange event to capture all devices */
		_pairedDevicesPPS.onReady = onPairedDevice;
		_pairedDevicesPPS.onChange = onPairedDevice;

		_pairedDevicesPPS.open("/pps/services/bluetooth/paired_devices/.all", JNEXT.PPS_RDONLY);

		/* Initialise PPS object to send commands and data to the PPS-Bluetooth */
		_controlPPS = _pps.createObject();
		_controlPPS.init();
		_controlPPS.open("/pps/services/bluetooth/control", JNEXT.PPS_RDWR);

		/* Initialise PPS object containing settings */
		_settingsPPS = _pps.createObject();
		_settingsPPS.init();
		_settingsPPS.open("/pps/services/bluetooth/settings", JNEXT.PPS_RDWR);

		/* Initialise PPS object responsible for notifying about BluettothStake state changes */
		_statusPPS = _pps.createObject();
		_statusPPS.init();
		_statusPPS.onChange = onStatusPPSChange;
		_statusPPS.open("/pps/services/bluetooth/status", JNEXT.PPS_RDONLY);

		/* Initialise PPS object which indicates what services currently connected and what is MAC of devices */
		_servicesPPS = _pps.createObject();
		_servicesPPS.init();
		_servicesPPS.onChange = onServicesPPSChange;
		_servicesPPS.open("/pps/services/bluetooth/services", JNEXT.PPS_RDONLY);
	},

	/**
	 * Sets the trigger function to call when a Bluetooth new device event is fired
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setNewDeviceTrigger:function (trigger) {
		_newDeviceTrigger = trigger;
	},
	/**
	 * Sets the trigger function to call when a Bluetooth new paired device event is fired
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setNewPairedDeviceTrigger:function (trigger) {
		_newPairedDeviceTrigger = trigger;
	},
	/**
	 * Sets the trigger function to call when a Bluetooth pairing complete event is fired
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setPairingCompleteTrigger:function (trigger) {
		_pairingCompleteTrigger = trigger;
	},
	/**
	 * Sets the trigger function to call when a Bluetooth search complete event is fired
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setSearchCompleteTrigger:function (trigger) {
		_searchCompleteTrigger = trigger;
	},
	/**
	 * Sets the trigger function to call when a Bluetooth search cancelled event is fired
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setSearchCancelledTrigger:function (trigger) {
		_searchCancelledTrigger = trigger;
	},
	/**
	 * Sets the trigger function to call when a Bluetooth search failed upon start
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setSearchStartFailedTrigger:function (trigger) {
		_searchStartFailedTrigger = trigger;
	},
	/**
	 * Sets the trigger function to call when a Bluetooth pairing failed is fired
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setPairingFailedTrigger:function (trigger) {
		_pairingFailedTrigger = trigger;
	},
	/**
	 * Sets the trigger function to call when a Bluetooth pairing cancelled event is fired
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setPairingCancelledTrigger:function (trigger) {
		_pairingCancelledTrigger = trigger;
	},
	/**
	 * Sets the trigger function to call when a Bluetooth init pairing failed event is fired
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setInitPairingFailTrigger:function (trigger) {
		_initPairingFailTrigger = trigger;
	},
	/**
	 * Sets the trigger function to call when a Bluetooth init pairing successful event is fired
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setInitPairingSuccessTrigger:function (trigger) {
		_initPairingSuccessTrigger = trigger;
	},
	/**
	 * Sets the trigger function to call when a Bluetooth authorization event is fired
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setAuthRequestTrigger:function (trigger) {
		_authRequestTrigger = trigger;
	},
	/**
	 * Sets the trigger function to call when a Bluetooth command failed fired
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setCommandFailedTrigger:function (trigger) {
		_commandFailedTrigger = trigger;
	},

	/**
	 * Sets the trigger function to call when a Bluetooth command busy fired
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setCommandBusyTrigger:function (trigger) {
		_commandBusyTrigger = trigger;
	},

	/**
	 * Sets the trigger function to call when a service connected fired
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setServiceConnectedTrigger:function (trigger) {
		_serviceConnectedTrigger = trigger;
	},

	/**
	 * Sets the trigger function to call when a service connected filed
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setServiceConnectFailedTrigger:function (trigger) {
		_serviceConnectFailedTrigger = trigger;
	},

	/**
	 * Sets the trigger function to call when service disconnected fired
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setServiceDisconnectedTrigger:function (trigger) {
		_serviceDisconnectedTrigger = trigger;
	},

	/**
	 * Sets the trigger function to call when service disconnect failed fired
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setServiceDisconnectFailedTrigger:function (trigger) {
		_serviceDisconnectFailedTrigger = trigger;
	},

	/**
	 * Sets the trigger function to call when there change in services
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setServiceStateChangedTrigger:function (trigger) {
		_serviceStateChanged = trigger;
	},

	/**
	 * Sets the trigger function to call when paired device deleted event fired
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setDeviceDeletedTrigger:function (trigger) {
		_deviceDeletedTrigger = trigger;
	},
	/**
	 * Sets the trigger function to call when paired device deleted event failed fired
	 * @param trigger {Function} The trigger function to call when the event is fired
	 */
	setDeviceDeleteFailedTrigger:function (trigger) {
		_deviceDeleteFailedTrigger = trigger;
	},

	/**
	 * Sets the trigger function to call when paired device deleted event failed fired
	 * @param trigger {Function} The trigger function to call when a low level (ACL) connection has been established with a remote device
	 */
	setAclConnectedTrigger:function (trigger) {
		_aclConnectedTrigger = trigger;
	},

	/**
	 * Set the Bluetooth name of the device
	 * @param name {String} The name to set
	 */
	setName:function (name) {
		_controlPPS.write({
			command:'set_name',
			data:name
		});
	},

	/**
	 * Set the Bluetooth device accessibility mode
	 * @param mode {Number} Value of accessibility mode <code>DEVICE_NOT_ACCESSIBLE, DEVICE_GENERAL_ACCESSIBLE, DEVICE_LIMITED_ACCESSIBLE, DEVICE_CONNECTABLE_ONLY, DEVICE_DISCOVERABLE_ONLY</code>
	 */
	setAccessibilityMode:function (mode) {
		_controlPPS.write({
			command:'set_access',
			data:mode
		});
	},

	/**
	 * Initiates search for Bluetooth devices.
	 */
	search:function () {
		_controlPPS.write({
			command:'device_search'
		});
	},

	/**
	 * Cancel a search in progress
	 */
	cancelSearch:function () {
		_controlPPS.write({
			command:'cancel_device_search'
		});
	},

	/**
	 * Initiates pairing to a Bluetooth device
	 * @param mac {String} MAC address of the device
	 */
	pair:function (mac) {
		if (mac) {
			_controlPPS.write({
				command:'initiate_pairing',
				data:mac
			});
		}
	},

	/**
	 * Cancel a pairing operation in progress
	 * @param mac {String} MAC address of the device
	 */
	cancelPair:function (mac) {
		if (mac) {
			_controlPPS.write({
				command:'cancel_pairing',
				data:mac
			});
		}
	},

	/**
	 * Send authorization information to the BT stack.
	 * @param mac {String} MAC address of the device
	 * @param parameters {Object} parameters of the authorization response
	 * Ex:
	 * {
	 *		type: {String},					//indicates type of the authorizations
	 *		response: {String}				//data passed for authorizations response
	 * }
	 */
	saveDevice:function (mac, parameters) {
		if (mac && parameters.type && typeof(parameters.response) != "undefined" && parameters.response != null) {

			var command = {
				"data":mac
			}

			// now we have to convert user friendly types to proper BT commands
			switch (parameters.type) {
				case PASS_KEY:
					/* Command for passing the passkey down to the device that you are going to pair with */
					command.command = "set_passkey";
					command.data2 = parameters.response;
					break;
				case ACCEPT_PASS_KEY:
					/* Command for providing a user confirmation for the pairing process. */
					command.command = "user_confirm";
					command.data2 = parameters.response;
					break;
				case AUTHORIZE:
					/* Command for responding to an authorize request during the pairing process */
					command.command = "authorize";
					command.data2 = parameters.response;
					break;
			}
			_controlPPS.write(command);
		}
	},

	/**
	 * Returns Bluetooth settings, reading from PPS
	 * @param settings {Array} A list of settings to get [optional]
	 * @returns {Object} Object representing Bluetooth settings
	 * Ex:
	 * {
	 *		accessibility:{Number},						//defines if host Bluetooth device will be visible to others
	 *		active_connections:{Boolean},				//indicated if there is any active connection established, true if connection established
	 *		btaddr:{String},							//provides MAC address of host Bluetooth adapter
	 *		enabled:{Boolean},							//defines if Bluetooth is enabled and operational, true idf operational
	 *		name:{String},								//defines Bluetooth device name which will be visible to others
	 *		running:{Boolean},							//indicated if Bluetooth stack is up and running, true if running
	 *		sapphire_device:{String},					//indicates MAC address of the device currently connected via Bridge
	 *		sapphire_device_p:{String},					//indicates MAC address of the device currently connected via Bridge
	 *		sapphire_enabled:{Boolean}					//indicates if Blackberry Bridge connected via SPP profile, true if connected
	 * }
	 */
	getOptions:function (settings) {
		if (settings && settings.length > 0) {
			var out = {};
			for (var i = 0; i < settings.length; i++) {
				out[settings[i]] = _settingsPPS.ppsObj[settings[i]];
			}
			return out;
		} else {
			return _settingsPPS.ppsObj;
		}
	},

	/**
	 * Saves Bluetooth settings to PPS
	 * @param settings {Object} Bluetooth settings to set
	 * Ex:
	 * {
	 *		accessibility:{Number},						//defines if host Bluetooth device will be visible to others
	 *		active_connections:{Boolean},				//indicated if there is any active connection established, true if connection established
	 *		btaddr:{String},							//provides MAC address of host Bluetooth adapter
	 *		enabled:{Boolean},							//defines if Bluetooth is enabled and operational, true idf operational
	 *		name:{String},								//defines Bluetooth device name which will be visible to others
	 *		running:{Boolean},							//indicated if Bluetooth stack is up and running, true if running
	 *		sapphire_device:{String},					//indicates MAC address of the device currently connected via Bridge
	 *		sapphire_device_p:{String},					//indicates MAC address of the device currently connected via Bridge
	 *		sapphire_enabled:{Boolean}					//indicates if Blackberry Bridge connected via SPP profile, true if connected
	 * }
	 */
	setOptions:function (settings) {
		if (settings && Object.keys(settings).length > 0) {
			_settingsPPS.write(settings);
		}
	},
	/**
	 * Connects to specified service on device with specified MAC address
	 * @param service {String} Service identifier
	 * @param mac {String} MAC address of the device
	 */
	connectService:function (service, mac) {
		if (service && mac) {
			if (service == SERVICE_ALL) {
				_controlPPS.write({
					"command":"connect_all",
					"data":mac
				});
			} else {
				_controlPPS.write({
					"command":"connect_service",
					"data":mac,
					"data2":service
				});
			}
		}
	},

	/**
	 * Disconnect from specified service on device with specified MAC address
	 * @param service {String} Service identifier
	 * @param mac {String} MAC address of the device
	 */
	disconnectService:function (service, mac) {
		if (service && mac) {
			if (service == SERVICE_ALL) {
				_controlPPS.write({
					"command":"disconnect_all",
					"data":mac
				});
			} else {
				_controlPPS.write({
					"command":"disconnect_service",
					"data":mac,
					"data2":service
				});
			}
		}
	},
	
	/**
	 * Gets a list of connected devices for bluetooth services.
	 * @param service {String} (optional) The bluetooth service.
	 */
	getConnectedDevices: function(service) {
		var devices = {};
		if(_servicesPPS && _servicesPPS.ppsObj) {
			if(!service || service == SERVICE_HFP || service == SERVICE_ALL) {
				devices[SERVICE_HFP] = _servicesPPS.ppsObj['hfp'];
			}
			if(!service || service == SERVICE_SPP || service == SERVICE_ALL) {
				devices[SERVICE_SPP] = _servicesPPS.ppsObj['spp'];
			}
			if(!service || service == SERVICE_PBAP || service == SERVICE_ALL) {
				devices[SERVICE_PBAP] = _servicesPPS.ppsObj['pbap'];
			}
			if(!service || service == SERVICE_MAP || service == SERVICE_ALL) {
				devices[SERVICE_MAP] = _servicesPPS.ppsObj['map'];
			}
			if(!service || service == SERVICE_PAN || service == SERVICE_ALL) {
				devices[SERVICE_PAN] = _servicesPPS.ppsObj['pan'];
			}
			if(!service || service == SERVICE_AVRCP || service == SERVICE_ALL) {
				devices[SERVICE_AVRCP] = _servicesPPS.ppsObj['avrcp'];
			}
		}
		return devices;
	},

	/**
	 * Remove a paired device and revoke its authorization to pair
	 * @param mac {Object} MAC address of the device
	 */
	removeDevice:function (mac) {
		if (mac) {
			_controlPPS.write({
				"command":"remove_device",
				"data":mac
			});
		}
	},

	/**
	 * Return list of paired devices.
	 *
	 * TODO This has to be changed when JNEXT extension would be able to retrieve values from .all
	 * right now I have to keep track of it on extension side.
	 *
	 * @returns {Object} The list of currently paired devices
	 */
	getPaired:function () {
		return _pairedDevices;
	},

	/**
	 * Get a list of available Bluetooth services for a device
	 * TODO Require proper implementation on native side
	 * @param mac {String} MAC address of the device
	 * @return {Object} list of available services on device
	 */
	getServices:function (mac) {
		return {};
	}
};
